1. 다형성 - 오버라이드(override)
 1-1 Override
 - 육군(Army), 해군(Navy), 공군(AirForce)은 Unit이라는 클래스를 통하여 공통속성을 정의하고 있다.
 - 공통속성 -> 이름(멤버변수 및 getter, setter), 공격(attack() 메서드)
 - 같은 이름이지만 다른 동작을 수행해야하는 필요성
	-> 모든 군대는 '공격'이라는 공통된 특성을 갖지만 공격하는 방법은 육 해 공 이 서로
	     다르게 처리되어야 한다.
 - 부모클래스가 갖고있는 기능을 자식클래스가 재정의
	-> 부모 클래스에 정의된 것과 동일한 이름을 갖는 메서드를 자식 클래스가
	정의한 경우, 부모클래스의 기능은 자식에게 가려진다.
	-> 이렇게 부모의 기능을 재정의 하는 것을 메서드 Override라 한다.
 - 하나의 이름으로 다양한 효과 얻기
	-> 모든 자식클래스가 동일한 이름의 메서드를 갖게 되므로 각 객체에 대하여
	attack() 이라는 이름을 사용하여 서로 다른 형태를 구현할 수 있게 된다.
 
 - 재정의된 메서드의 흐름(2.Override 참조)
	-> e.say();
	: 자식클래스에 구현된 메서드가 없기 때문에 부모클래스에 정의된 메서드를 찾아간다.
	-> k.say();
	: 자식클래스가 부모와 같은 이름의 메서드를 정의하고 있기 때문에 k객체에게는 부모 클래스가
	정의하고 있는 say()메서드가 가려지게 된다.

 1-2 Super 키워드
    - 클래스의 상속관계에서 자식클래스가 부모클래스를 가리키는 예약어★★★★★
    - 사용방법
	-> 멤버변수 이름 앞에 명시 ex) super.이름 
	: 부모클래스의 멤버변수를 의미한다. 하지만 부모클래스의 멤버 변수는
	이미 모두 상속되어 있기 때문에 이 경우에는 'this' 키워드를 사용하는 것과
	동일한 결과이기 때문에 잘 사용하지 않는다. 
	
	-> 메서드 이름 앞에 명시 ex) super.메서드()
	: 부모클래스의 메서드를 의미한다. 
	: 재정의 되지 않은 메서드 -> 이미 상속되어 있기 때문에 this키워드를 사용하것과
	동일한 결과를 갖는다. 
	: 재정의 된 메서드 -> Override된 메서드 이름 앞에 사용하게 되면
	[재정의 되기 이전의 원본 메서드(부모클래스의 메서드)를 의미한다.]★★★

	-> 키워드 자체를 메서드처럼 사용
	: 부모 클래스의 생성자를 의미한다.

 1-3. 상속을 통한 메서드의 기능 확장 처리
  - super(2/4) 참고
  - Hello클래스가 Korean에 상속되고 , Korean 클래스가 say() 메서드를
  Override 처리하게 되면 Korean 클래스의 객체는 더 이상 부모의 say()에 접근할 수 없게 된다.
  ----------------------------------------------------------------------------------------------------------
  - super(3/4) 참고
  - 만약 부모 클래스가 가지고 있는 say()메서드에 추가적인 기능을 구현하고자 한다면
    코드를 그대로 복사해서 사용해야 할 것이다.
  - 이런 경우 원본기능에 대한 수정이 발생할 경우 부모 클래스와 자식 클래스를 모두 수정해야
   하기 때문에 소스코드의 유지보수 효율성이 떨어지게 된다.
  ----------------------------------------------------------------------------------------------------------
  - super(4/4) 참고
  - super 키워드는 부모 클래스의 메서드를 호출하는 기능을 가지고 있기 때문에, Override된 자식
   클래스의 메서드에서 super 키워드를 사용하면, 재정의 되기 이전의 부모클래스에 대한 메서드를 호
   출 할 수있다.
  - super 키워드를 사용하여 부모의 메서드를 호출한 뒤에 추가적인 기능을 정의하고 있으므로, 부모의
   원본 메서드에 대한 기능 확장 효과가 있다.

 1-4 상속 관계에서의 생성자 처리
  -생성자가 정의된 클래스의 상속제한
	-> 생성자는 상속되지 않는다 ( 특수한 형태의 메소드)
	-> 그렇지만 디폴트 생성자는 어차피 자동으로 나오기 때문에 문제가 없지만
	-> 내가 오버로딩 해둔 생성자는 즉, 파라미터가 있는 생성자
	-> 반드시 선언 해줘야 하기 때문에 자식에서 super로 불러준다.
	-> 생성자가 정의된 클래스는 객체 생성을 위해서 생성자 파라미터를 반드시 전달 받아야하기 때문에,
	파라미터를 갖는 생성자가 정의된 클래스를 상속 받게 되면 에러가 발생하게 된다.

  - 부모 생성자의 강제 호출
	-> 생성자가 정의된 클래스를 상속받은 경우에는 자식클래스의
	생성자를 통해서 부모 생성자를 강제로 호출 해야 한다.
	-> 부모의 생성자를 호출하는 방법은 super 키워드를 메서드 이름으로
	사용하는 것이다.

  1-5. 메서드 재정의 과정에서 오타가 발생한 경우
     - 부모클래스의 say() 메서드를 재정의 하는 과정에서
     개발자의 실수로 인해 sai()라고 메서드를 추가되었다면
    java는 새로운 메서드를 추가한 것으로 인식하고 특별한 에러를 표시하지 않는다.
    say() 메서드가 재정의 된것으로 생각한 개발자는 이 경우 의도하지 않은 결과를 만나게 될 것이다.
    - 매서드 재정의 과정에서 오타방지 옵션
    --> "@Override" 는 이 키워드가 명시된 위치 아래에 정의되는 메서드가 부모 클래스에 존재하지
        않을 경우 구문 에러로 처리한다.
     - 부모 클래스의 메서드 재정의 하고자 할 경우, 의도치 않은 실수를 예방하기 위한 ' 오타방지옵션'이다
    - 여러 개의 메서드를 재정의 한다면 재정의 되는 모든 메서드들 위에 각기 명시해야 한다.

----------------------------------------------------------------------------------------------------------------------------------
day02

1. 다형성 - 오버로드(Overload)
 1-1. 메서드 오버로드(Overload)
   - 원칙적으로 하나의 클래스 안에서는 동일한 이름의 메서드가 두 개 이상 존재 할 수 없지만,
  이를 가능하게 하는 예외적인 기법
 
 1-2. 이름이 동일한 메서드를 정의하기 위한 조건
   - 메서드간에 파라미터가 서로 달라야 한다.
	-> 파라미터의 데이터 타입이 다르다.
	(데이터 형이 동일하고 변수의 이름이 다른 경우는 동일한 파라미터로 인식된다)
	-> 파라미터의 개수가 다르다.
	-> 서로 다른 데이터형을 갖는 파라미터들의 전달 순서가 다르다.
   - 리턴형이 다른 경우는 오버로드의 성립에 아무런 영향을 주지 않는다.★★★ (몰랐던사실)

 1-3. 오버로드의 예시
   - 파라미터의 데이터 형이 서로 다르기 때문에 오버로드 성립
	public void foo( int a ) {}
	public void foo( long a ) {}
	public void foo(  ) {}

   - 파라미터의 개수가 서로 다르기 때문에 오버로드 성립
	public void foo( int a ) {}
	public void foo( int a, int b ) {}

   - 데이터 형의 전달 순서가 서로 다르기 때문에 오버로드 성립
	public void foo( int a, long b ) {}
	public void foo( long a, int b ) {}
	// public void foo( int a, int b ) {} --> 얘는 순서가 다른게 아니다 둘다 int int 여서

   - 오버로드는 하나의 메서드를 호출 할 수있는 모든 경우의 수를 미리 준비해 놓음으로서,
   메서드를 만드는 측은 번거로울 수 있지만, 메서드를 호출하는 측은 데이터 타입을 신경쓰지 않고,
   편리하게 사용 할 수 있게 하기 위함이다.

  
  1-4. 객체 생성 방법의 다양화
    - 생성자 역시 메서드의 한 종류이므로 Overload가 가능하다.
    - 생성자를 Overload할 경우, 해당 클래스에 대해 '객체를 생성하는 방법'을 다양하게 준비 할 수 있게 된다.
  
  1-5. this 키워드를 사용한 생성자 Overload
    - this 키워드의 용법
	-> 메서드처럼 사용할 경우, 현재 클래스의 다른 생성자를 의미한다.
    - this 키워드를 사용하여 생성자 Overload를 간결하게 처리하기
	-> 파라미터가 서로 다른 생성자들이 하나의 완전한 생성자를 호출하도록 하여,
	데이터의 초기화를 한곳에서 일괄적으로 처리하도록 구현할 수 있다.
   
2. 객체 형변환
  2-1. 객체 형변환
   - Java 기본 유형의 데이터들 처럼 객체 참조변수의 경우에도 형변환(casting)이 이루어진다.
   - 서로 다른 클래스 유형으로부터 나온 객체 참조변수들 간의 대입에는 일정한 규칙이 있다.

	Parent parent = new Child();

   - 위의 대입연산에서 왼쪽 항(Parent)과 오른쪽 항(Child)의 객체 유형이 서로 다른 경우,
   두 유형이 서로 상속관계에 있고 왼쪽 객체가(Parent) 오른쪽 객체(Child)의 상위 클래스인
   경우에만 암묵적인 형 변환이 일어난다.
   - 하위 클래스에서 상위클래스 유형으로 할당하는 것은 가능하나 그 반대의 경우에는 명시적 형 변환을 해야한다.
  
   2-2. 객체간의 암묵적 형 변환( 영상 봐라)
    왼쪽 부모 = 오른쪽 자식
     A a1 = new B();
     A a2 = new X();
     -----------------
     A a3 = new C();
     A a4 = new Y();
     -----------------
     B b1 = new C();
     X x1 = new Y();
     -----------------
     C c1 = new C();
     B b2 = c1; --> 이것도 된다. 오우 신기
     -------------------
     Y y = new Y();
     X x2 = y; --> 이렇게 부모에 자식을 대입하는 것도 가능
     X x1 = new Y(); -> 이거랑 똑같다고 생각하면 됨

    2-3. 암묵적 형변환과 메서드 오버라이드
      - 암묵적 형변환은 부모를 상속받는 자식객체의 기능을 부모에게 물려받은 기능만
        사용하도록 제한한다.
      - 그러므로 암묵적 형변환이 발생하게 되면 [오버라이드된 기능만 사용가능]★★★하고,
       추가적으로 구현한 기능은 사용할 수 없다.
      - 주의할 점은 기능의 제한이지 기능의 변경은 아니라는 점이다.
      - 상속관계의 객체를 부모형태로 변화하면 클래스의 종류를 구부하지 않고 일관된 기능을
      호출 할 수 있다.
      - 하지만, 추가적으로 구현한 기능은 사용할 수 없게 되므로 원래의 기능을 다시 사용할 수 있는
      방법이 필요해 졌다.
	Unit u1 = new Army();
	Unit u2 = new Navy():
	Unit u3 = new Airforce():
	u1.attack();
	u2.attack();
	u3.attack();
	
	//부모 클래스가 가지고 있는 기능이 아니므로 에러
	u1.tank();
	u2.nucleus();
	u3.bumbing();

  2-4. 명시적 형변환
    - 부모 클래스의 객체를 자식 클래스 형태로 변환하는 것
    - 형변환을 위해서는 다음과 같이 변환할 클래스 이름을 명시적으로 지정해 주어야한다,
	ChildClass child = (ChildClass) parent;

  2-5. 명시적 형변환의 조건
    - 객체가 최초 생성될 때 자식 클래스 형태로 생성되고, 부모의 형태로 암묵적 형변환이 된 상태를
     다시 원래의 자식 클래스 형태로 되돌릴 경우에만 가능하다.
	ChildClass child1 = new ChildClass();
	ParentClass parent = child1; // 암묵적 형 변환
	ChildClass child2 = (ChildClass)parent;  // 명시적 형 변환
	// 암묵적 형 변환으로 만든 것을 
	// 새로운 자식클래스에 넣는거네.  
	
	Army army1 = new Army();
	Unit u = army1;
	Army army2 = (Army) u;
	------------------------------
	Unit u = new Navy();
	Navy navy = (Navy)u;
	----------------------------

	*명시적 형 변환이 불가능한 경우
	Unit u = new Unit();
	Army army = (Army)u;
	--> 얘는 안됨 
	--> 최초 객체 생성이 부모형태로 만들어진 경우 불가능하다.
	----------------------------
	Army army = new Army();
	Unit u = army;
	Navy navy =(Navy)u;
	--> 최초 생성된 것과 다른 형식으로 변환하는 것은 불가능하다.
	

 3. 객체 배열
   3-1. 객체 배열
     - 일반 데이터 타입의 배열과 동일한 개념으로, 같은 클래스의 객체 여러개를 그룹화 할 수 있다.
 
     - 일반 데이터 형의 배열 생성과 객체 배열 생성 비교
	일반 데이터 형 배열의 경우
	int[] data = new int[3];

	객체 배열의 경우
	Army[] data =new Army[3];

     - 각 경우에 대한 배열의 요소 할당 처리
	-> 일반 데이터 형은 단순히 값을 대입 하지만, 객체배열은 'new'를 사용하여
	객체를 할당해야 한다.

	- 일반 데이터형 배열의 경우
	data[0]= 10;
	data[1]= 1;
	data[2]= 5;

	- 객체 배열의 경우
	data[0] = new Army();
	data[1] = new Army();
	data[2] = new Army();

    - 정리
	-> 객체형 변환
	: 같은 부모클래스에서 파생된 서로다른 자식 클래스의 객체들은 부모형태로
	암묵적 형변환 되어 일관된 형식으로 사용 가능하다.

	-> 객체 배열
	: 동일한 클래스의 객체는 배열로 묶어서 여러 개를 한꺼번에 제어할 수있다

    - 부모 클래스의 배열에 자식클래스의 객체를 넣기
	-> 배열의 생성이 부모클래스로 지정 되었을 경우, 모든 자식 클래스의 객체들은
	그 배열에 포함 될 수 있다.
	
	Unit[] unit = new Unit[3];
	// 배열의 요소 할당 과정에서 암묵적 형변환이 이루어진다.
	unit[0] = new Army();
	unit[1] =new Navy();
	unit[2] =new Airforce();

	-> 일괄 저리가 가능하다.
	-> 서로 다른 객체를 부모 형태로의 배열에 담게 되면, 반복문으로 일괄 처리가 가능해진다.
	-> 이 때 배열의 각 요소를 통해 사용하는 메서드가 Override 되어 있을 경우
	부모의 메서드가 아니라 자신이 재정의한 기능을 뜻한다.

	for (int i=0; i<unit.length; i++){
		unit[i].attack();
	}

----------------------------------------------------------------------------------------------------------------------------
day03

1. 객체 배열과 객체 형변환 함께 사용하기
  1-1. 원래 기능으로 복귀하기
    - 배열의 각 요소가 확장한 기능을 사용하기 위해서는 원래의 클래스 형태로
     명시적 형변환이 이루어 져야 한다.
    - 하지만 반복적으로 처리되는 과정에서 몇 번째 요소가 어떤 클래스에서
     최초로 생성되었는지를 판단하기란 쉽지 않다.

  1-2. instanceof 연산자의 사용
    - instanceof 연산자는 어떤 객체에 대한 출처를 판단하여 boolean 형으로
     결과를 반환한다. --> 즉 객체 배열에서 각 객체가 가지고 있는 다른 메서드를 쓸때
      있는 지 없는지 판단할 때 사용 가능
	if(unit[0] instanceof Army){ // 첫번째가 Army로 형변환 시킨거냐?
		// 맞다면 다시 자식클래스로 명시적 형변환 시킨다.
		Army temp = (Army)unit[0]; // 명시적 형변환
		temp.tank(); 
		// 처음에는 부모클래스가 형변환으로 인해 자식클래스만 가지고 있는 메서드
		// 사용이 어려웠는데 지금은 다시 명시적형변환으로 바꿔서
		// 자식만 있는 메서드 사용가능
	}
    - 반복문 안에서 사용할 경우 배열의 크기나 인덱스의 위치에 종속되지 않고,
     배열에 속해 있는 모든 객체들에 대해 명시적 형변환을 처리 할 수 있다.
	for(int i=0; i<unit.length; i++){
		if(unit[i] instanceof Army){
			Army temp = (Army)unit[i];
		}
		else if(unit[i] instanceof Navy){
			Navy temp = (Navy)unit[i];
		}
		else {
			Airforce temp = (Airforce)unit[i];
		}
	}

2. 추상화
  2-1. 상속성과 다형성의 필요성
    - 상속성은 객체간의 공통적인 기능을 관리하기 위한 기법으로.
    코드의 재사용을 통하여 프로그램의 유지보수를 편리하게 한다.
    - 다형성(Override, Overload)은 서로 다른 기능이지만 메서드의 이름을
     공통되게 처리함으로서 전체 프로그램의 일관성을 유지하게 한다.

  2-2. Override처리의 문제 발생 가능성
   - '@Override' 키워드를 사용하지 않고 메서드를 재정의 하는 과정에서
    메서드 이름에 실수가 발생하더라도 에러가 아닌 새로운 메서드의 정의로
    인식되므로 의도하지 않은 실행결과를 가져올 수 있다.
   - '@Override' 키워드를 사용하더라도 자식 클래스를 구현하는 개발자의 
    실수로 인하여 부모의 기능을 재정의 하지 않았다면 다향성의 구현은
    이루어지지 않게 된다.

  2-3. 상속처리시, Override를 강제하기
    - 추상화 기법은 특정 클래스를 상속받은 경우,
    부모의 특정 메서드들을 무조건 재정의하도록 강제하는 기법이다.
    - 특정 메서드를 재정의하도록 강제함으로써, 자식 클래스들을 작성하기 위한
    가이드 역할을 할 수 있다.
    - 즉, 추상화 기법은 Java 클래스를 작성하기 위한 설계도를 소스코드 형태로
    제시하는 역할을 한다.

  2-4. 추상 메서드 만들기
    - 추상 메서드를 정의하기 위해서는 'abstract' 키워드를 사용하여 메서드를 정의한다.
    - 추상 메서드는 자식 클래스가 구현해야하는 메서드의 가이드라인만
     제시하기 위한 목적으로 사용되기 때문에, 선언만 가능하고 구현부가 없다.
	// 선언만 가능하고, 구현부를 위한 블록이 존재하지 않는다.
	public abstract void say();

  2-5. 추상 메서드를 포함한 클래스
    - 추상 메서드를 하나이상 포함하고 있는 클래스는 반드시 ' 추상클래스 '로 정의되어야 한다.
    - 추상 클래스는 'abstract' 키워드를 사용하여 정의할 수 있다.

	// 추상 클래스의 정의
	public abstact class Hello{
		public abstract void sayHello();
	}

    - 추상 클래스는 객체를 생성할 수 없고, 반드시 상속을 통해서만 사용될 수 있다.
    즉 , 추상 클래스는 다른 자식 클래스를 위한 '가이드라인'의 역할을 한다. 

3. 인터페이스
  3-1. 추상 클래스의 한계
    - 자바 클래스 간의 상속에는 하나의 부모만 존재할 수 있기 때문에,
    앞의 상황에서 요구하는 다중 상속의 구현은 불가능하다.

  3-2. Interface 란?
   - 완벽한 추상화를 구현하기 위한 java Class의 한 종류이다.
   - 다중 상속이 가능하기 때문에 용도별로 세분화 하여 필요한 요소만
   상속할 수 있다.

	추상 클래스
	-> 멤버변수, 생성자, 메서드, 추상메서드를 포함할 수있다.
	-> 이 클래스를 상속받는 자식 클래스는 다른 클래스를 
	상속 받을 수 없다.
	-> 객체의 생성이 불가능하다.

	인터페이스
	-> 추상메서드만 포함할 수 있다.
	-> 인터페이스는 다중 상속이 가능하다.
	-> 객체의 생성이 불가능하다.

  3-3. Interface 정의
   - 인터페이스의 정의
   - 기본적으로 인터페이스에 추가되는 모든 메서드는 추상메서드이기 때문에,
    'abstract'키워드를 명시할 필요가 없다.
	public interface Unit{
		public void attack();
		public void shield();
		
	} 

  3-4. 인터페이스 상속을 위한 implements 키워드
   - 인터페이스 상속은 implements 키워드를 사용한다.
   - 인터페이스도 추상화를 구현하고 있기 때문에,
   인터페이스를 상속받는 클래스는 인터페이스내의 모든 메서드들을
   반드시 재정의 해야 한다.
   - 인터페이스는 콤마(,)로 연결하여 여러 개를 동시에 상속받을 수 있다.
	public class Monster implements Fight, Move{

	}
   - 필요한 경우 다른 클래스와 동시에 상속 받을 수 있다.
	public class Monster extends Foo implements Fight, Move{
	
	} //--> 이게 가능하다.

 4. Static 
 
	public class Article{
		private int count;		// 전체 글 수
		privateString category;	// 카테고리
		
		private int num; 		//글번호
		pirvate String title;		// 제목
		pirvate String regDate;	//날짜
	}

    - 멤버변수는 모든 객체가 독립적으로 갖는 고유 데이터이기 때문에
     게시물의 수라는 공유 데이터를 모든 게시물이 갖게 된다.
    - 즉, 각각의 객체가 중복된 데이터를 갖게 된다.

  4-1. 객체간의 공유 자원을 표현하는 static 키워드
   - 클래스를 설계할 때, 멤버변수 중 모든 객체에서 공통적으로 사용해야 하는
   값에 static을 붙인다.
	
	public class Article{
		private static int count;	// 전체 글 수
		private static String category;// 카테고리
		
		private int num; 		//글번호
		pirvate String title;		// 제목
		pirvate String regDate;	//날짜
	}
   - static이 붙은 멤버변수는 객체의 개수에 상관 없이 단 하나만 생성되면
   이를 모든 객체가 공유하기 떄문에 메모리를 효율적으로 사용할 수 있다.

  4-2. 컴퓨터의 메모리 구조
   - 코드영역(고정영역) // 한번 선언되면 계속 남아있는 영역
	-> 프로그램의 코드가 저장되는 영역
	이 영역에 저장된 명령어들을 CPU가 하나씩 가져가 실행한다.

   - 데이터 영역(고정영역)
	-> 전역변수와 static으로 선언되는 변수가 할당된다.
	이 영역에 할당되는 변수들은 프로그램 시작과 동시에 메모리 공간이
	할당되어 종료될 때까지 남아있게 된다.

   - 힙 역역(동적영역) // 썻다 지웠다가 할 수 있는 영역
	-> 프로그래머가 원하는 시점에 변수를 할당하고 소멸시키는 영역
	메모리 동적 할당시 사용된다. 객체가 생성되는 영역이다.

   - 스택 영역(동적영역)
	-> 함수가 실행될 때 사용되는 파라미터와 지역변수에 대한
	메모리 공간, 함수의 종료와 함께 소멸된다.
---------------------------------------------------------------------------------------------------------------------------
day04
1. Static
  1-1. 메모리 영역
    - 고정영역
	-> static변수와 static멤버함수가 생성된다.
	-> 이 영역의 자원들은 프로그램이 실행되는 동안 항상 존재한다.
	-> 동적 메모리 영역이 자원들은 항상 존재하는 것이 아니기 때문에
	static 멤버함수는 동적 메모리 영역의 멤버변수를 사용하거나,
	static이 아닌 일반 멤버함수를 호출 할 수 없다.

    - 동적영역
	-> 객체, 객체 안의 멤버변수, 메서드, 메서드가 호출되었을 때 사용되는
	지역변수 등이 생성된다.
	-> 이 영역의 자원들은 생성과 제거가 유동적으로 반복된다.
	-> static 자원은 항상 존재하는 것이므로 동적 영역에서는 static변수를
	활용하거나, static멤버 함수를 호출할 수 있다.

=> 메모리 영역의 차이 때문에 static 메서드는 동적 메모리 영역의 멤버변수를
사용하거나, static이 아닌 일반 멤버함수를 호출할 수 없다.



2. Package
  2-1. java Package
    - 패키지 -> 클래스에 대한 묶음 단위
    - 클래스를 용도별이나, 기능별로 그룹화 한 것을 말한다.
    소스코드는 폴더로 분류된 형태로 존재하게 된다.
    - 서로 다른 패키지에 속해 있다면 다른 클래스와 이름이 동일하더라도
    충돌이 발생하지 않는다.
   ( 서로 다른 폴더에는 이름이 같은 파일들이 존재할 수 있다.)

  2-2. 패키지 이름
   - 패키지 이름의 일반적인 정의 형식 -> 회사 도메인이름의 역순.
				프로젝트이름의 소문자
   - ex) com.koreait.static , com.koreait.boxing, com.koreait.override 뭐 이런식
   - ' . ' 으로 나누어서 이름을 적으면 ' . ' 기준으로 파일이 3개 생긴거다.(com / koreait / static)

  2-3. 패키지 확인
   - 패키지에 소속된 클래스 파일은 첫 번째 라인에서
    자신이 소속된 클래스 패키지 이름을 선언해야 한다.
   - 이클립스가 트리영역에서 소스를 분류하는 작업을 통해 구문을 자동으로
   추가해 주지만, 간혹 처리되지 않을 때도 있으므로 package 구문에서 에러가 발생할 경우
   소스가 어떤 패키지에 있는지 확인하여 직접 이 구문을 수정해 주어야 한다.

  2-4. 패키지에 속해 있는 클래스에 대한 객체 생성
    - 다른 패키지의 클래스를 사용하고자 할 경우, 패키지의 이름을 포함한
     FullName으로 사용해야 한다.
	study.java.bbs.Article article = new study.java.bbs.Article();
    - 이러한 번거로움을 피하고자 클래스 정의 전에 import 구문을 사용하여
    특정 클래스의 이름이 어떤 패키지에 소속되어 있는지를 명시할 수 있다.
   	import study.java.bbs.Article;
	Article article = new Article();

3. ClassPath
 3-1. ClassPath란
   - 컴파일이 완료된 *.class 파일들이 위치하는 경로
   - ClassPath를 컴파일시에 옵션으로 설정하면 그 안의 모든 클래스들을
   참조할 수 있게 된다.
   - 즉 객체를 생성할 때 대상클래스의 소스 없이도 컴파일된 결과물만 참조하여
   객체 생성 및 메서드 호출 등이 가능해 진다.

 4. 라이브러리
  4-1. 라이브러리란?
    - 한개 이상의 패키지들을 배포하기 용이하도록 압축한 형태
    - 다른 프로그램에서 라이브러리 안에 포함된 기능을 활용할 수 있다.
    
 5. JAVA API
  5-1. JAVA 기본 API
   - 우리가 사용하는 JDK안에는 이미 수많은 라이브러리가 포함되어 있고,
    이 라이브러리 안에는 프로그램 개발에 필요한 패키지들이 기본적으로 포함되어 있다.
    프로그램 개발에 필요한 패키지들이 기본적으로 포함되어 있다.
   - 자바 프로그래밍은 이러한 라이브러리들의 기능을 활용하여 이루어 진다.
   - 이렇게 프로그램 개발을 위하여 기본적으로 제공되는 기능들을 API라고 한다.

6. Wrapper Class
 6-1. Wrapper Class란?
   - Java는 데이터를 관리하기 위하여 기본데이터 타입을 지원하지만,
   클래스를 통해서 만들어진 객체를 통한 데이터 관리도 가능하다.
   - 기본 데이터 타입의 변수를 객체형태로 사용해야 하는 경우가 있는데,
   이때 기본형 타입을 객체로 포장할 필요가 있다.
   - 포장 클래스(Wrapper Class)는 특정 기본형 타입을 나타내는 용도로 사용된다.
 
 6-2. Wrapper Class의 의미
   - 초창기 Java언어는 기본 자료형의 연산 보다도 Wrapper Class를 사용한 연산이
   더 많이 이루어 졌으나, Java 언어가 발전함에 따라서 기본 자료형과
   Wrapper 클래스 간에 연산에 차이가 없어졌다.
   - 최근의 Java언어는 Wrapper클래스와 기본 자료형을 구분하지 않고,
    사용하기 때문에 객체로써의 특별한 의미가 없어졌다고 볼 수 있다.

 6-3. Wrapper Class의 객체 만들기
   - 각각의 Wrapper Class 객체는 자신과 대응되는 기본 자료형의 데이터를
   파라미터로 전달 받는다.
	int num = 1;
	Integer wrapper = new Integer(num);

 6-4. Wrapper Class 형변환
   - 기본 자료형과 Wrapper Class 간에는 서로 암묵적 형변환이 가능하다.
	// 암묵적 형변환
	int num = 100;
	Integer wrapper = num; 
	-----------------------------------------------------
	Integer wrapper = new Interger(100);
	int num = wrapper; 
	
   - 모든 Wrapper Class는 static 데이터 형태로 Wrapper Class에 대응되는
   자료형에 대한 최소값과 최대값을 가지고 있다.
	int max = Integer.MAX_VALUE; // 이게 클래스여서 메소드 접근 연산자가 가능한거다 뭔지 알지?
	int min = Integer.MIN_VALUE;

 6-5. 문자열 데이터의 형변환- 중요★★★
   - 1과 "1"의 차이
	-> 기본 자료형과 문자열 데이터간의 연산에서는
	기본 자료형 데이터가 문자열로 변환된 후,
	문자열간의 연산으로 처리된다.

	int a = 1;  
	String b= "1";
	System.out.println(a+b); // "11" --> int가 String으로 자동변환함.

   - 사용자 입력값에 대한 연산
	-> 모든 프로그램 플랫폼에서 사용자의 입력값은 String으로 처리된다.
	-> 만약, 인터넷 뱅킹에서 2개의 계좌로 송금할 금액을 각각
	입력하였을 때, 총 금액을 계산한다면 다음과 같이 처리될 것이다.
	String money1="5000";
	String money2="3000";
	String total = money1 + money2; // "50003000"

	-> Wrapper Class에는 기본 자료형의 모양을 띄고 있는 문자열 데이터를
	실제 기본 자료형으로 변환 시키는 기능이 포함되어 있다.
	-> 오늘날의 Java에서 Wrapper Class의 가장 큰 의미는 바로 이 부분이다.
	String money1="5000";
	String money2="3000";
	int m1 = Interger.parselnt(money1);
	int m2 = Interger.parselnt(money2); // 클래스 형변환 해주는것 parselnt라는 메서드
	System.out.println(m1 + m2); // 8000
-------------------------------------------------------------------------------------------------------------------
day05

1. Math
  1-1. Math 클래스
    - Math클래스는 흔히 계산을 하는데 도움이 되는 많으 수의 기본적인 수학 함수들을 
     제공 한다.
    - Math클래스는 Java표준 클래스 라이브러리의 java.lang패키지에 정의되어 있다.
    - Math클래스의 모든 메서드들은 static 메서드로, 클래스의 객체를 생성하지 않고
     그 메서드가 정의된 클래스 이름을 통해 호출될 수 있다. 

2. String
  --> 이클립스 확인

3. 정규표현식
  3-1. 정규표현식 이란?
    - 정규표현식(Regular expression)은 특정한 규칙을 가진 문자열의 집합을
     표현하는데 사용하는 '형식언어' 이다.
    - 정규표현식은 많은 텍스트 편집기와 프로그래밍 언어에서
     '문자열의 검색과 치환'을 위해 지원하고 있다.
    - 자바에서도 정규표현식을 1.4부터 지원하기 시작했으며, 관련된 주요 클래스들은
     java.util.regex 패키지에 포함되어 있다.

  3-2. 정규표현식의 사용
    - boolean java.util.regex.Pattern.matches( String param1, CharSeqeunce param2 )
    - param1 : 정규표현식 문자열이다.
    - param2 : 형식을 검사받기 위한 내용
    - 즉 위의 기능은 param1이 param2의 형식에 맞는지를 검사하고
     결과를 boolean으로 리턴한다.

 
---------------------------------------------------------------------------------------------------------
day 06
1. 정규 표현식

2. 예외 처리
 2-1. 에러의 종류
   - 컴파일 에러
	-> 소스코드의 구문오류로 인하여 컴파일이 불가능한 상태
	-> 이클립스에서 빨간색으로 표시되는 경우에 해당한다.
	-> 프로그램을 실행하기 전에 발견되므로 상대적으로 고치기 쉽다.

   - 런타임 에러
	-> 구문상의 에러는 없지만, 프로그램이 실행되는 과정에서
	다양한 경우의 수에 대응하지 못하여 발생하는 예외상황
	-> 런타임에러가 발생하면 프로그램은 강제로 종료된다.
	-> 우리가 프로그램의 에러라고 부르는 현상은 대부분 런타임에러에
	해당한다.

  2-2. 런타임 에러의 종류
    - 런타임 에러에는 프로그램 자체의 구조적인 문제로 인한 논리적 오류와
    자바 가상 머신 자체의 문제로 인한 오류, 그리고 예외가 있다.

    - 논리 오류
	-> 논리적 모순이 생기지 않도록 코드를 작성해야한다.
    - 자바 가상 머신 자체 오류
	-> 프로그래머가 책임질 수 있는 수준의 오류가 아니다.
    - 예외(Exception)
	-> 프로그램 실행 중에 발생할 수 있는 예기치 않은 사건으로,
	프로그래머의 노력으로 처리할 수 있다.
	-> 자바 가상머신은 프로그램 실행중에 예외가 발생하면
	관련된 예외 클래스로부터 예외 객체를 생성하여 프로그램에서
	지정된 예외처리 구문으로 넘긴다.
	-> 예외가 발생하면
	프로그램에 지정된 예외 처리 구문이 자바 가상머신에 의해
	호출되고, 이 때 전달되는 예외 객체를 넘겨받아 적절한
	처리를 수행한다.

  2-3. Java의 예외처리
    - Java에서는 try~ catch~ finally 구문을 통해 프로그래머가 예외상황에
    대응할 수 있도로 하고 있다.
	try{
	//기본적으로 실행되는 부분
	}
	catch(예외클래스이름 객체이름){
	// try블록에서 예외가 발생한 경우 이 곳으로 제어가 넘어온다.
	}
	finally{
	// 예외 상황의 발생 여부에 상관 없이 무조건 실행되는 부분
	// finally 블록은 생략 가능하다.
	}

     - try블록 실행도중 catch에서 명시한 예외 클래스에 해당하는 런타임에러가
     발생하면, try블록을 즉시 중단하고 catch블록이 실행 된 후, finally 블록이 실행된다.
     - 예외가 발생하지 않을 경우에는 try블록 종료 후 finally 블록이 실행된다. 
 
  2-4. catch블록을 사용한 복한 에러 처리
    - catch블록은 에러가 예상되는 상황에 대해 복수로 명시하는 것이
    가능하다.
 
  2-5. Exception 클래스 
    - Java에서 예외 상황을 의미하는 모든 클래스들의 최상위 클래스
    - 이 클래스의 이름으로 catch 블록을 구성하면, 모든 예외 상황에
    일괄적으로 대응할 수는 있지만, catch 블록이 세분화 된 경우와는
    달리 상황 별 개별적인 처리는 불가능하다.
    - Exception 클래스에 대한 예외처리는 대부분 맨 마지막 catch 블록에
    명시하여 '마지막 알 수 없는 에러'를 의미하도록 구성한다.

  2-6. 에러객체 'e'의 기능
    - e.getMessage();
	-> 간략한 에러 메시지를 리턴한다.
	-> e.getLocaliseMessage()도 같은 기능을 한다.

    - e.printStackTrace();
	-> 실제 예외 상황시에 출력되는 메시지를 강제로 출력한다. ( 그 에러나면 나오는 빨간글씨들)
	-> 개발자가 catch 블록 안에서 예외 상황을 분석하기 위한
	용도로 사용한다.
------------------------------------------------------------------------------------------------------------------------
day07

1. SingleTon 디자인 패턴
 1-1. SingleTon  디자인 패턴이란?
   - 프로그램 내의 여러 곳에서 반복적으로 사용되어야 하는 객체에 대해
    전역적으로 범위를 갖도록 객체를 생성하고, 이 객체를 여러곳에서 공유
    하기 위한 클래스 작성 패턴
   - 이러한 패턴을 통해 생성된 객체를 싱글톤 객체라고 한다.

 1-2. SingleTon 객체의 이점
   - 프로그램의 전역에서 활용할 재료로 사용되는 공유기능을 하나만 생성하여
   여러 곳에서 재상용함으로 해서 메모리를 효율적으로 사용할 수 있다.
   - 단 한번만 객체를 생성하면 다시 객체를 생성할 필요가 없기 때문에,
   해당 기능을 사용할 때마다 객체를 일일이 생성해야 하는 번거로움을 피할 수 
   있다.

2. 컬렉션 프레임워크(Collection Framework)소개
 2-1. 컬렉션 프레임워크 란?
   - 다수의 데이터를 쉽게 처리할 수 있는 표준화된 방법을 제공하는
    클래스들로, 기본 배열형태의 자료저장에서 좀더 다양한 데이터들을
    저장하기 위한 필수 클래스이다.

 2-2. HashMap 
   - 데이터에 이름표를 적용하여 저장하기
   - HashMap 클래스는 Map 인터페이스를 상속 받는 '자료 보관소'이기 때문에,
   암묵적 객체 형변환의 귝칙에 따라 Map 형태로 선언하고 HashMap형태로 할당한다.
   - 선언과 할당시에 HashMap의 이름표로 사용할 데이터 형(String)과
    HashMap에 저장할 데이터형을 클래스의 이름으로 명시해야 하는데,
    이를 '제너릭스' 라 한다.
   - 제너릭스에 명시할 수 있는 데이터 형은 반드시 클래스 이름이여야 하기 때문에
    기본 자료형을 보관할 경우 Wrapper클래스의 이름을 사용해야 한다.
	Map<String, 저장할 데이터의 클래스 이름(INTEGER, FLOAT이런거..)> data
		=new HashMap<String, 저장할 데이터의 클래스 이름(INTEGER, FLOAT이런거..)>();
   -기존에 저장된 데이터와 중복되는 이름이 저장될 경우, 기존에 저장된 데이터를
   덮어 씌우게 된다.

 2-3. ArrayList
   - 무제한 확장 가능한 배열
   - ArrayList는 List 인터페이스를 상속받는 클래스로, 데이터를 이름표없이
    무제한으로 보관 할 수 있다.
   - ArrayList에 추가되는 데이터는 순차적으로 배열과 같은 인덱스 번호를 
    부여 받는다.
   - 상위 인터페이스형으로 선언하고 ArrayList 클래스로 객체를 할당하며,
    선언과 할당시에는 보관하고자하는 자료형에대한 제너릭스를 명시한다.
	List<저장할 데이터의 클래스 이름> list
		=new ArrayList<저장할 데이터의 클래스 이름>();
--------------------------------------------------------------------------------------------------------
day08
1. File클래스
 1-1. java.io.File
   - File클래스는 파일 또는 폴더에 대한 정보를 제공하는 클래스이다.
   - File클래스의 객체는 정보를 조회하고자 하는 파일이나 폴더의 경로에 대한
   문자열을 생성자 파라미터로 전달하는 형태로 만들 수 있다.
   이 때 파라미터로 전달되는 경로가 실제 존재하지 않더라도
   File객체의 생성이 가능하다.
	File file = new File("C:\photo\food.jsp");
	-----------------------------------------------
	File file = new File("C:\photo","food.jsp");

 1-2. 경로설정하기
   - 운영체제간의 호환성 유지를 위한 '/'의 사용
		-> 경로 문자열을 설정할 때 원도우기반에서는 역슬래시(\)를 사용하지만
		이 경우 이스케이프 문자를 사용하여 "\\"의 형식으로 사용해야 하고
		가급적 다른 운영체제와의 호환성을 위해 슬래시(/)를 사용하는 것이 좋다.

   - 절대경로
	-> 작업 디렉토리와 관계없이 절대적인 위치를 의미하는 경로
	-> 하나의 파일을 얻기 위해 모든 경로를 처음부터 끝까지 나열하는것
	-> 리눅스: /etc/httpd/conf/httpd.conf
	-> 윈도우: C:/Windows/System32/drivers/etc/hosts 

   - 상대경로
	-> 작업 디렉토리를 기준으로 상대적인 위치를 의미하는 경로
	-> 리눅스 : ./conf/httpd.conf
	-> 윈도우 : ../drivers/etc/hosts

 1-3. 문자 인코딩
   - 문자나 기호들의 집합을 컴퓨터에서 저장하거나 통신에 사용할
   목적으로 부호화 하는 방법
   - 아스키(ASCII)
   - UTF-8 

 1-4. 스트림이란?
   - 입출력에서 stream이란 디바이스의 입출력 방식이 character단위이든
    block 단위이든 관계 없이 "1바이트"씩 "연속"적으로 전달되는 형태로,
    추상화된 상태를 의미한다.
   - 입출력 장치는 개별적인 특성이 있으므로 읽고, 쓰는 단위가 각각 다르지만,
    스트림은 이런한 일련의 과정을 추상화하여 모든 디바이스를 character 단위로만
    사용하도록 한다.
   - 즉, 입출력 디바이스의 특성을 무시하고 하나의 단일한 입출력 인터페이스로
    다룰 수 있도록 하는 것이 stream 이다.

 1-5. 자바의 스트림 관련 클래스
   - 스트림 관련 클래스들은 각각 inputStream(입력/읽기), outputStream(출력/저장)
    과 관련된 인터페이스를 상속 받기 때문에 모두 동일한 메서드를 가지고 있다.
   - 개발자는 상황에 따라 적절한 클래스를 사용하기만 하면 동일한 방법으로
    스트림을 사용할 수 있다.

 1-6. 파일 저장 과정
   - 저장을 위한 빈 파일 생성하기
	-> OutputStream의 객체를 생성한다.
   - 파일에 내용 쓰기
	-> 저장할 내용을 byte배열로 변환한다.
	-> 변환된 배열을 OutputStream의 write()메서드에게 파라미터로 전달한다.
   - 파일 닫기
	-> OutputStream객체로 close()메서드를 호출하여 스트림을 닫는다.

 1-7. 파일 저장시 유의사항
   - OutputStream은 각각의 단계마다 예외처리를 강제적으로 요구한다.
   - try ~ catch 블록이 형성되는 과정에서 변수의 유효성 범위에 대한 처리에
   유의해야 한다.

 1-8. 파일 읽기 과정
   - 파일을 읽기 위한 InputStream 객체 생성하기
   - 읽은 내용을 담기 위한 빈 byte 배열 생성하기
	-> 파일의 용량 크기 만큼 배열의 사이즈를 지정해야 한다.
   - 파일의 내용 읽기
	-> 읽은 내용을 담기 위한 byte배열을 inputStream 객체의
	read() 메서드에게 파라미터로 전달한다.
   - 사용이 완료된 스트림 닫기
	-> InputStream 객체의 close() 메서드를 호출하여 스트림을 닫는다.
   - 읽은 내용을 문자열로 변환하기
	-> byte배열을 String 클래스의 생성자에게 전달하여 문자열로 변환한다.
	-> 이 과정에서 어떤 인코딩을 사용할지를 함께 설정해야 한다.













